set dotenv-load
set dotenv-required
set quiet

jenkins_url := '${JENKINS_PROTOCOL}://${JENKINS_HOST}:${JENKINS_PORT}'

sudo := if env('SUDO') == '1' { 'sudo ' } else { '' }

alias j := jcli
alias dl := download
alias s := send-config
alias r := reload-config
alias v := view-config

# Initialize Jenkins
[group("Init")]
init-jenkins: start instructions

# Instructions after initializing Jenkins
[group("Init")]
instructions:
    #!/usr/bin/bash
    s=""
    s+="1. Go to {{ YELLOW }}{{ jenkins_url }}/user/$(just _get-secret jenkins_username)/security{{ NORMAL }} (login if prompted)"
    s+="\n2. Create your API token"
    s+="\n3. Copy the token and set {{ RED + BOLD }}JENKINS_API_TOKEN{{ NORMAL }} in your {{ YELLOW }}.env{{ NORMAL }} file"
    s+="\n4. Run {{ GREEN }}just dl{{ NORMAL }} to download the Jenkins CLI"
    s+="\n\nJenkins and your local environment should now be fully setup."
    s+="\n\nIf you make changes to the configuration via the Jenkins UI and want to save"
    s+="\nthose changes, you can view the current configuration used by Jenkins using"
    s+="\n{{ GREEN }}just v{{ NORMAL }}, copy the modified parts, and update the {{ YELLOW }}jenkins.yml{{ NORMAL }} file."
    s+="\n\n{{ BG_BLUE }} NOTE {{ NORMAL }}"
    s+="\nJob configurations are not obtainable in Job DSL API syntax and need to"
    s+="\nbe manually written in {{ YELLOW }}jenkins.yml{{ NORMAL }}."
    s+="\n\nIf you want to see this text again use {{ GREEN }}just instructions{{ NORMAL }}"
    printf "$s\n"

# Check if Jenkins is ready
[group("Init")]
check:
    count=$({{ sudo }}docker compose logs | grep -i -c "Jenkins is fully up and running"); \
    if [ $count -gt 0 ]; then \
        echo "Jenkins is ready"; \
    else \
        echo "Jenkins is not ready"; \
    fi

# Create initial files
[group("Init")]
init-files:
    file="./secrets/secrets.properties"; if [ ! -f "$file" ]; then cp ${file}.example $file; echo "Created $file"; fi
    file="./secrets/github_app_team_key.pem"; if [ ! -f "$file" ]; then touch $file; echo "Created $file"; fi

# Start Jenkins
[group("Docker")]
start:
    {{ sudo }}docker compose up --wait --build

# Stop Jenkins
[group("Docker")]
stop:
    {{ sudo }}docker compose down

# Destroy all of Jenkins, including the volumes
[group("Docker")]
destroy:
    {{ sudo }}docker compose down -v --rmi all

# View commands for the Jenkins server
[group("Jenkins CLI")]
help:
    just j help
    echo "You can also go to {{ YELLOW }}{{ jenkins_url }}/cli{{ NORMAL }} to view commands."

# View help information for the Jenkins CLI
[group("Jenkins CLI")]
help-cli:
    java -jar $JENKINS_CLI

# Downloads the Jenkins CLI locally
[group("Init")]
download:
    curl {{ jenkins_url }}/jnlpJars/jenkins-cli.jar --output $JENKINS_CLI

# Shorthand to use the Jenkins CLI
[group("Jenkins CLI")]
jcli *args:
    java -jar $JENKINS_CLI -s {{ jenkins_url }} -auth $(just _get-secret jenkins_username):$JENKINS_API_TOKEN {{ args }}

# Sends the JCasC configuration to the Jenkins container
[group("Jenkins CLI")]
send-config:
    {{ sudo }}docker cp jenkins.yml $JENKINS_CONTAINER:/var/jenkins_home/jenkins.yaml

# Reloads the JCasC configuration on the Jenkins container
[group("Jenkins CLI")]
reload-config:
    just j reload-jcasc-configuration
    echo "JCasC config reloaded"

# Displays the current JCasC configuration used by Jenkins
[group("Jenkins CLI")]
view-config:
    just j export-configuration

# https://plugins.jenkins.io/github/#plugin-content-manual-mode
# https://stackoverflow.com/a/51545557
# Tunneling using localtunnel. Only for local development
[group("Extra")]
tunnel:
    echo "Port: {{ GREEN }}$JENKINS_PORT{{ NORMAL }}"
    npx localtunnel -p $JENKINS_PORT -s "$TUNNEL_SUBDOMAIN" --print-requests

# Tunnel password
[group("Extra")]
tunnel-pw:
    curl https://loca.lt/mytunnelpassword

_get-secret prop:
    grep "^{{ prop }}=" ./secrets/secrets.properties | cut -d "=" -f 2-

# https://github.com/jenkinsci/github-branch-source-plugin/blob/master/docs/github-app.adoc#creating-the-github-app
# Convert GitHub keys to a compatible Jenkins format
[group("Extra")]
convert-key in out:
    openssl pkcs8 -topk8 -inform PEM -outform PEM -in {{ in }} -out {{ out }} -nocrypt

# Displays useful Jenkins URLs. Use ip=1 to show all URLs with an IP
[group("Extra")]
urls ip="0":
    #!/usr/bin/bash
    url="{{ jenkins_url }}"
    address=$(just ip)
    
    if [ "{{ ip }}" == "ip=1" ]; then
        url="${JENKINS_PROTOCOL}://${address}:${JENKINS_PORT}"
    fi
    
    width=30
    s=""
    s+=$(printf "%-${width}s %s" "{{ YELLOW }}Job DSL API{{ NORMAL }}" "${url}/plugin/job-dsl/api-viewer/index.html")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}User Security{{ NORMAL }}" "${url}/user/$(just _get-secret jenkins_username)/security")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Blue Ocean{{ NORMAL }}" "${url}/blue/pipelines")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}CLI Page{{ NORMAL }}" "${url}/cli")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Pipeline Syntax{{ NORMAL }}" "${url}/pipeline-syntax")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Local URL{{ NORMAL }}" "${url}")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Public URL{{ NORMAL }}" "${JENKINS_PROTOCOL}://${address}:${JENKINS_PORT}")
    printf "$s\n"

# Get your current public ip
[group("Extra")]
ip:
    curl -s ifconfig.me

# Watch logs
[group("Extra")]
logs:
    {{ sudo }}docker compose logs -f -t

# Sort plugins.txt
[group("Extra")]
plugins:
    content=$(cat plugins.txt | sort); \
    echo "$content" > plugins.txt

# Update the files in the current directory with gitsnip (for prod environment)
[group("Extra")]
update-files branch="main":
    gitsnip $GITSNIP_REPO $GITSNIP_FOLDER . -b {{ branch }}
