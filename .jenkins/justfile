set dotenv-load
set dotenv-required

# git bash will treat a leading '/' as a path, so do this work-around
forward_slash := if os_family() == 'windows' { '//' } else { '/'}

alias jc := jcli
alias gc := get-cli

# Initialize Jenkins
[group("Init")]
init: secrets start init-text

# Instructions after initializing Jenkins
[group("Init")]
init-text:
    @echo -e "1. Go to {{ YELLOW }}$JENKINS_URL/user/${JENKINS_USER}/security{{ NORMAL }} (login if prompted)\n\
    2. Create your API token\n\
    3. Copy the token and set {{ RED + BOLD }}JENKINS_API_TOKEN{{ NORMAL }} in your {{ YELLOW }}.env{{ NORMAL }} file\n\
    4. Ensure all credentials are filled in {{ YELLOW }}creds/{{ NORMAL }}\n\
    5. Run {{ GREEN }}just get-cli{{ NORMAL }} to download the Jenkins CLI\n\
    6. Run {{ GREEN }}just post-init{{ NORMAL }} to finish initialization\n\
    \nIf you want to see this text again use {{ GREEN }}just init-text{{ NORMAL }}"

# Check if Jenkins is ready
[group("Init")]
@check:
    count=`docker compose logs | grep -i -c "Jenkins is fully up and running"`; \
    if [ $count -gt 0 ]; then \
        echo "{{GREEN}}Jenkins is ready"; \
    else \
        echo "{{RED}}Jenkins is not ready"; \
    fi

# Create secrets from .env
[group("Init")]
secrets:
    mkdir -p secrets
    echo $JENKINS_USER > secrets/jenkins_username
    echo $JENKINS_PASSWORD > secrets/jenkins_password

# Imports necessary configuration for Jenkins
[group("Init")]
post-init: import-creds import-jobs
    @echo "{{ GREEN }}Jenkins is now fully configured"

# Start Jenkins
[group("Docker")]
start:
    docker compose up --wait --build

# Stop Jenkins
[group("Docker")]
stop:
    docker compose down

# Destroy all of Jenkins, including the volumes
[group("Docker")]
destroy:
    docker compose down -v --rmi all

# View commands for the Jenkins server
[group("Jenkins CLI")]
@help:
    just jcli help
    echo "You can also go to {{ YELLOW }}$JENKINS_URL/cli{{ NORMAL }} to view commands."

# View help information for the Jenkins CLI
[group("Jenkins CLI")]
@help-cli:
    java -jar $JENKINS_CLI

# Downloads the Jenkins CLI locally
[group("Init")]
get-cli:
    curl $JENKINS_URL/jnlpJars/jenkins-cli.jar --output $JENKINS_CLI

# Shorthand to use the Jenkins CLI
[group("Jenkins CLI")]
@jcli *args:
    java -jar $JENKINS_CLI -s $JENKINS_URL -auth $JENKINS_USER:$JENKINS_API_TOKEN {{ args }}

# Imports credentials to Jenkins
[group("Jenkins CLI")]
import-creds:
    for filepath in creds/*.xml; do \
        just jc create-credentials-by-xml $JENKINS_PRIMARY_STORE $JENKINS_PRIMARY_DOMAIN < $filepath; \
    done

# Imports and reloads the JCasC configuration to Jenkins
[group("Jenkins CLI")]
import-config:
    docker cp jenkins.yml $JENKINS_CONTAINER:/var/jenkins_home/jenkins.yaml
    just jcli reload-jcasc-configuration

# Imports jobs to Jenkins
[group("Jenkins CLI")]
import-jobs:
    for filepath in jobs/*; do \
        name=`basename ${filepath%.*}`; \
        just jcli create-job $name < $filepath; \
    done

# Exports jobs from Jenkins
[group("Jenkins CLI")]
export-jobs:
    for name in `just jc list-jobs`; do \
        just jcli get-job $name > jobs/$name.xml; \
    done

# Deletes all jobs from Jenkins
[group("Jenkins CLI")]
delete-jobs:
    for name in `just jc list-jobs`; do \
        just jcli delete-job $name; \
    done

# Webhook tunneling using https://smee.io/. Only for local development
wh-tunnel:
    npx smee-client -p 8080 --path {{ forward_slash }}github-webhook
