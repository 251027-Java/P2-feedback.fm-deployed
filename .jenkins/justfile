set dotenv-load
set dotenv-required
set quiet

jenkins_url := '${JENKINS_PROTOCOL}://${JENKINS_HOST}:${JENKINS_PORT}'

alias j := jcli
alias dl := download
alias s := send-config
alias r := reload-config
alias v := view-config

# Initialize Jenkins
[group("Init")]
init-jenkins: start instructions

# Instructions after initializing Jenkins
[group("Init")]
instructions:
    echo -e "1. Go to {{ YELLOW }}{{ jenkins_url }}/user/`just _get-secret jenkins_username`/security{{ NORMAL }} (login if prompted)\n\
    2. Create your API token\n\
    3. Copy the token and set {{ RED + BOLD }}JENKINS_API_TOKEN{{ NORMAL }} in your {{ YELLOW }}.env{{ NORMAL }} file\n\
    4. Run {{ GREEN }}just dl{{ NORMAL }} to download the Jenkins CLI\n\
    \nJenkins and your local environment should now be fully setup.\n\
    \nIf you make changes to the configuration via the Jenkins UI and want to save\n\
    those changes, you can view the current configuration used by Jenkins using\n\
    {{ GREEN }}just v{{ NORMAL }}, copy the modified parts, and update the {{ YELLOW }}jenkins.yml{{ NORMAL }} file.\n\
    \n{{ BG_BLUE }} NOTE {{ NORMAL }}\n\
    Job configurations are not obtainable in Job DSL API syntax and need to\n\
    be manually written in {{ YELLOW }}jenkins.yml{{ NORMAL }}.\n\
    \nIf you want to see this text again use {{ GREEN }}just instructions{{ NORMAL }}"

# Check if Jenkins is ready
[group("Init")]
check:
    count=`docker compose logs | grep -i -c "Jenkins is fully up and running"`; \
    if [ $count -gt 0 ]; then \
        echo "Jenkins is ready"; \
    else \
        echo "Jenkins is not ready"; \
    fi

# Create initial files
[group("Init")]
init-files:
    file="./secrets/secrets.properties"; if [ ! -f "$file" ]; then cp ${file}.example $file; echo "Created $file"; fi
    file="./secrets/github_app_team_key.pem"; if [ ! -f "$file" ]; then cp ${file}.example $file; echo "Created $file"; fi

# Start Jenkins
[group("Docker")]
start:
    docker compose up --wait --build

# Stop Jenkins
[group("Docker")]
stop:
    docker compose down

# Destroy all of Jenkins, including the volumes
[group("Docker")]
destroy:
    docker compose down -v --rmi all

# View commands for the Jenkins server
[group("Jenkins CLI")]
help:
    just j help
    echo "You can also go to {{ YELLOW }}{{ jenkins_url }}/cli{{ NORMAL }} to view commands."

# View help information for the Jenkins CLI
[group("Jenkins CLI")]
help-cli:
    java -jar $JENKINS_CLI

# Downloads the Jenkins CLI locally
[group("Init")]
download:
    curl {{ jenkins_url }}/jnlpJars/jenkins-cli.jar --output $JENKINS_CLI

# Shorthand to use the Jenkins CLI
[group("Jenkins CLI")]
jcli *args:
    java -jar $JENKINS_CLI -s {{ jenkins_url }} -auth `just _get-secret jenkins_username`:$JENKINS_API_TOKEN {{ args }}

# Sends the JCasC configuration to the Jenkins container
[group("Jenkins CLI")]
send-config:
    docker cp jenkins.yml $JENKINS_CONTAINER:/var/jenkins_home/jenkins.yaml

# Reloads the JCasC configuration on the Jenkins container
[group("Jenkins CLI")]
reload-config:
    just j reload-jcasc-configuration
    echo "JCasC config reloaded"

# Displays the current JCasC configuration used by Jenkins
[group("Jenkins CLI")]
view-config:
    just j export-configuration

# https://plugins.jenkins.io/github/#plugin-content-manual-mode
# https://stackoverflow.com/a/51545557
# Tunneling using localtunnel. Only for local development
[group("Extra")]
tunnel:
    echo "Port: {{ GREEN }}$JENKINS_PORT{{ NORMAL }}"
    npx localtunnel -p $JENKINS_PORT -s "$TUNNEL_SUBDOMAIN" --print-requests

# Tunnel password
[group("Extra")]
tunnel-pw:
    curl https://loca.lt/mytunnelpassword

_get-secret prop:
    grep "^{{ prop }}=" ./secrets/secrets.properties | cut -d "=" -f 2-

_job-exists job:
    for name in `just j list-jobs`; do \
        if [ $name = "{{ job }}" ]; then \
            echo 1; break; \
        fi \
    done

# https://github.com/jenkinsci/github-branch-source-plugin/blob/master/docs/github-app.adoc#creating-the-github-app
# Convert GitHub keys to a compatible Jenkins format
[group("Extra")]
convert-key in out:
    openssl pkcs8 -topk8 -inform PEM -outform PEM -in {{ in }} -out {{ out }} -nocrypt

# Displays useful Jenkins URLs
[group("Extra")]
urls:
    width=30; \
    printf "%-${width}s %s\n" "{{ YELLOW }}Job DSL API{{ NORMAL }}" "{{ jenkins_url }}/plugin/job-dsl/api-viewer/index.html"; \
    printf "%-${width}s %s\n" "{{ YELLOW }}User Security{{ NORMAL }}" "{{ jenkins_url }}/user/`just _get-secret jenkins_username`/security"; \
    printf "%-${width}s %s\n" "{{ YELLOW }}Blue Ocean{{ NORMAL }}" "{{ jenkins_url }}/blue/pipelines"; \
    printf "%-${width}s %s\n" "{{ YELLOW }}CLI Page{{ NORMAL }}" "{{ jenkins_url }}/cli"

# Watch logs
[group("Extra")]
logs:
    docker compose logs -f -t

# Sort plugins.txt
[group("Extra")]
plugins:
    cat plugins.txt | sort > plugins.txt
